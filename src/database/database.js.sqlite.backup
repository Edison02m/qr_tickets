const sqlite3 = require('sqlite3').verbose();
const path = require('path');
const fs = require('fs');

// Funci√≥n para obtener la ruta de la base de datos
function getDatabasePath() {
  const isDev = process.env.NODE_ENV === 'development';
  
  if (isDev) {
    // En desarrollo, usar la ruta relativa
    return path.join(__dirname, '../../database.sqlite');
  } else {
    // En producci√≥n, intentar diferentes ubicaciones
    const possiblePaths = [
      // Ruta en recursos de la aplicaci√≥n
      path.join(process.resourcesPath, 'database.sqlite'),
      // Ruta en app.asar.unpacked
      path.join(process.resourcesPath, 'app.asar.unpacked', 'database.sqlite'),
      // Ruta en el directorio de la aplicaci√≥n
      path.join(process.resourcesPath, '..', 'database.sqlite'),
      // Carpeta de datos del usuario
      path.join(require('os').homedir(), 'AppData', 'Roaming', 'electronic-project', 'database.sqlite')
    ];
    
    // Buscar el archivo en las diferentes ubicaciones
    for (const dbPath of possiblePaths) {
      if (fs.existsSync(dbPath)) {
        return dbPath;
      }
    }
    
    // Si no se encuentra, crear en la carpeta de datos del usuario
    const userDataPath = path.join(require('os').homedir(), 'AppData', 'Roaming', 'electronic-project');
    if (!fs.existsSync(userDataPath)) {
      fs.mkdirSync(userDataPath, { recursive: true });
    }
    
    const userDbPath = path.join(userDataPath, 'database.sqlite');
    return userDbPath;
  }
}

const dbPath = getDatabasePath();

// Funci√≥n helper para obtener fecha/hora local en formato SQLite
function getLocalDateTime() {
  const now = new Date();
  const offset = now.getTimezoneOffset() * 60000; // offset en milisegundos
  const localDate = new Date(now.getTime() - offset);
  return localDate.toISOString().slice(0, 19).replace('T', ' ');
}

// Funci√≥n helper para obtener solo la fecha local en formato YYYY-MM-DD
function getLocalDate(date = new Date()) {
  const offset = date.getTimezoneOffset() * 60000;
  const localDate = new Date(date.getTime() - offset);
  return localDate.toISOString().split('T')[0];
}

class Database {
  // Actualizar cierre de caja existente
  updateCashClosure({ usuario_id, fecha_inicio, total_ventas, cantidad_tickets, detalle_tipos }) {
    return new Promise((resolve, reject) => {
      this.db.run(
        `UPDATE cierres_caja SET total_ventas = ?, cantidad_tickets = ?, detalle_tipos = ?, fecha_cierre = datetime('now', 'localtime')
         WHERE usuario_id = ? AND date(fecha_inicio) = date(?)`,
        [total_ventas, cantidad_tickets, detalle_tipos, usuario_id, fecha_inicio],
        function(err) {
          if (err) reject(err);
          else resolve({ updated: this.changes });
        }
      );
    });
  }
  // Obtener todos los cierres de caja
  getAllCashClosures() {
    return new Promise((resolve, reject) => {
      this.db.all(
        `SELECT cc.*, u.nombre as usuario_nombre, u.usuario as usuario_usuario
         FROM cierres_caja cc
         JOIN usuarios u ON cc.usuario_id = u.id
         ORDER BY cc.fecha_cierre DESC`,
        [],
        (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        }
      );
    });
  }

  // Obtener cierre de caja por fecha y usuario
  getCashClosureByDateAndUser(usuario_id, fecha_inicio) {
    return new Promise((resolve, reject) => {
      this.db.get(
        `SELECT cc.*, u.nombre as usuario_nombre, u.usuario as usuario_usuario
         FROM cierres_caja cc
         JOIN usuarios u ON cc.usuario_id = u.id
         WHERE cc.usuario_id = ? AND date(cc.fecha_inicio) = date(?)
         ORDER BY cc.id DESC
         LIMIT 1`,
        [usuario_id, fecha_inicio],
        (err, row) => {
          if (err) reject(err);
          else resolve(row || null);
        }
      );
    });
  }

  // Obtener todos los cierres de todos los usuarios para una fecha espec√≠fica (para admin)
  getAllCashClosuresByDate(fecha) {
    return new Promise((resolve, reject) => {
      this.db.all(
        `SELECT cc.*, u.nombre as usuario_nombre, u.usuario as usuario_usuario
         FROM cierres_caja cc
         JOIN usuarios u ON cc.usuario_id = u.id
         WHERE date(cc.fecha_inicio) = date(?)
         ORDER BY u.nombre ASC`,
        [fecha],
        (err, rows) => {
          if (err) {
            reject(err);
          } else {
            // Calcular totales consolidados
            const totalVentas = rows.reduce((sum, row) => sum + parseFloat(row.total_ventas || 0), 0);
            const totalTickets = rows.reduce((sum, row) => sum + parseInt(row.cantidad_tickets || 0), 0);
            
            resolve({
              fecha: fecha,
              cierres: rows,
              totales: {
                total_ventas: totalVentas,
                cantidad_tickets: totalTickets,
                cantidad_usuarios: rows.length
              }
            });
          }
        }
      );
    });
  }

  // Crear o actualizar cierre de caja (ahora siempre crea nuevo registro)
  upsertCashClosure({ usuario_id, fecha_inicio, total_ventas, cantidad_tickets, detalle_tipos }) {
    const self = this;
    return new Promise((resolve, reject) => {
      // Usar transacci√≥n para asegurar consistencia
      self.db.serialize(() => {
        self.db.run('BEGIN TRANSACTION', (err) => {
          if (err) {
            reject(err);
            return;
          }

          // Paso 1: Crear el nuevo cierre (marcado como cerrado por defecto)
          self.db.run(
            `INSERT INTO cierres_caja (usuario_id, fecha_inicio, total_ventas, cantidad_tickets, detalle_tipos, cerrado)
             VALUES (?, ?, ?, ?, ?, 1)`,
            [usuario_id, fecha_inicio, total_ventas, cantidad_tickets, detalle_tipos],
            function(err) {
              if (err) {
                self.db.run('ROLLBACK', () => reject(new Error(`Error al crear cierre de caja: ${err.message}`)));
                return;
              }
              
              const cierreId = this.lastID;
              
              // Paso 2: Actualizar todas las ventas del d√≠a que no tienen cierre asignado
              self.db.run(
                `UPDATE ventas 
                 SET cierre_caja_id = ?
                 WHERE usuario_id = ? 
                   AND date(fecha_venta) = date(?)
                   AND cierre_caja_id IS NULL
                   AND anulada = 0`,
                [cierreId, usuario_id, fecha_inicio],
                function(errUpdate) {
                  if (errUpdate) {
                    self.db.run('ROLLBACK', () => reject(errUpdate));
                  } else {
                    const ventasActualizadas = this.changes;
                    
                    // Paso 3: Commit si todo sali√≥ bien
                    self.db.run('COMMIT', (errCommit) => {
                      if (errCommit) {
                        self.db.run('ROLLBACK', () => reject(errCommit));
                      } else {
                        resolve({ 
                          action: 'created', 
                          id: cierreId,
                          ventas_actualizadas: ventasActualizadas
                        });
                      }
                    });
                  }
                }
              );
            }
          );
        });
      });
    });
  }

  // Crear un nuevo cierre de caja (mantenido para compatibilidad)
  createCashClosure({ usuario_id, fecha_inicio, total_ventas, cantidad_tickets, detalle_tipos }) {
    return new Promise((resolve, reject) => {
      this.db.run(
        `INSERT INTO cierres_caja (usuario_id, fecha_inicio, total_ventas, cantidad_tickets, detalle_tipos, cerrado)
         VALUES (?, ?, ?, ?, ?, 1)`,
        [usuario_id, fecha_inicio, total_ventas, cantidad_tickets, detalle_tipos],
        function(err) {
          if (err) reject(err);
          else resolve({ id: this.lastID });
        }
      );
    });
  }

  // Cerrar un cierre de caja (marcar como cerrado)
  closeCashClosure(cierreId) {
    return new Promise((resolve, reject) => {
      // Validar que el ID sea v√°lido
      if (!cierreId || typeof cierreId !== 'number') {
        reject(new Error('ID de cierre de caja inv√°lido'));
        return;
      }

      // Verificar que el cierre existe y obtener sus datos
      this.db.get('SELECT * FROM cierres_caja WHERE id = ?', [cierreId], (err, cierre) => {
        if (err) {
          reject(new Error(`Error al buscar el cierre de caja: ${err.message}`));
          return;
        }

        if (!cierre) {
          reject(new Error('El cierre de caja no existe'));
          return;
        }

        if (cierre.cerrado === 1) {
          reject(new Error('Este cierre de caja ya est√° cerrado'));
          return;
        }

        // Marcar como cerrado
        this.db.run(
          'UPDATE cierres_caja SET cerrado = 1, fecha_cierre = datetime("now", "localtime") WHERE id = ?',
          [cierreId],
          (err) => {
            if (err) {
              reject(new Error(`Error al cerrar el cierre de caja: ${err.message}`));
            } else {
              resolve({ id: cierreId, cerrado: true });
            }
          }
        );
      });
    });
  }

  // Reabrir un cierre de caja cerrado
  reopenCashClosure(cierreId) {
    return new Promise((resolve, reject) => {
      // Validar que el ID sea v√°lido
      if (!cierreId || typeof cierreId !== 'number') {
        reject(new Error('ID de cierre de caja inv√°lido'));
        return;
      }

      // Verificar que el cierre existe y obtener sus datos
      this.db.get('SELECT * FROM cierres_caja WHERE id = ?', [cierreId], (err, cierre) => {
        if (err) {
          reject(new Error(`Error al buscar el cierre de caja: ${err.message}`));
          return;
        }

        if (!cierre) {
          reject(new Error('El cierre de caja no existe'));
          return;
        }

        if (cierre.cerrado === 0) {
          reject(new Error('Este cierre de caja ya est√° abierto'));
          return;
        }

        // Marcar como abierto
        this.db.run(
          'UPDATE cierres_caja SET cerrado = 0 WHERE id = ?',
          [cierreId],
          (err) => {
            if (err) {
              reject(new Error(`Error al reabrir el cierre de caja: ${err.message}`));
            } else {
              resolve({ id: cierreId, cerrado: false });
            }
          }
        );
      });
    });
  }

  // Obtener todos los tickets vendidos (para admin, sin filtrar por fecha)
  getAllDailySales() {
    return new Promise((resolve, reject) => {
      this.db.all(
        `SELECT v.id as venta_id, v.fecha_venta, v.total, v.anulada,
                u.nombre as vendedor, u.usuario as vendedor_usuario,
                t.id as ticket_id, t.codigo_qr, t.precio as ticket_precio, tt.nombre as tipo_ticket,
                t.anulado, t.usado, t.fecha_uso, t.puerta_codigo, t.impreso, t.fecha_impresion
         FROM tickets t
         JOIN ventas v ON t.venta_id = v.id
         JOIN usuarios u ON v.usuario_id = u.id
         JOIN tipos_ticket tt ON t.tipo_ticket_id = tt.id
         ORDER BY v.fecha_venta DESC, v.id DESC, t.id DESC`,
        [],
        (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        }
      );
    });
  }

  // Anular una venta (cambia el estado anulada y los tickets asociados)
  annulSale(ventaId) {
    return new Promise((resolve, reject) => {
      const self = this;
      
      // PASO 1: Verificar si la venta existe y obtener sus datos
      this.db.get(
        `SELECT v.*, u.nombre as nombre_vendedor 
         FROM ventas v 
         LEFT JOIN usuarios u ON v.usuario_id = u.id 
         WHERE v.id = ?`,
        [ventaId],
        (err, venta) => {
          if (err) {
            reject(new Error(`Error al buscar la venta: ${err.message}`));
            return;
          }
          
          if (!venta) {
            reject(new Error('La venta que intenta anular no existe'));
            return;
          }
          
          if (venta.anulada === 1) {
            reject(new Error('Esta venta ya fue anulada anteriormente'));
            return;
          }
          
          // PASO 2: Verificar si alg√∫n ticket ya fue utilizado
          this.db.all(
            'SELECT codigo_qr, usado FROM tickets WHERE venta_id = ?',
            [ventaId],
            (err, tickets) => {
              if (err) {
                reject(new Error(`Error al verificar tickets de la venta: ${err.message}`));
                return;
              }
              
              const ticketsUsados = tickets.filter(t => t.usado === 1);
              
              if (ticketsUsados.length > 0) {
                const codigosUsados = ticketsUsados.map(t => t.codigo_qr).join(', ');
                const mensaje = `No se puede anular la venta porque ${ticketsUsados.length} ticket(s) ya fueron utilizados:\n${codigosUsados}\n\nLas ventas con tickets usados no pueden anularse por razones de seguridad y auditor√≠a.`;
                reject(new Error(mensaje));
                return;
              }
              
              // PASO 3: Verificar si el cierre de caja asociado a la venta est√° cerrado
              // Primero verificar si la venta tiene un cierre asignado
              if (venta.cierre_caja_id) {
                self.db.get(
                  'SELECT * FROM cierres_caja WHERE id = ?',
                  [venta.cierre_caja_id],
                  (err, cierreCaja) => {
                    if (err) {
                      reject(new Error(`Error al verificar cierre de caja: ${err.message}`));
                      return;
                    }
                    
                    if (cierreCaja && cierreCaja.cerrado === 1) {
                      const fechaCierre = new Date(cierreCaja.fecha_cierre).toLocaleDateString('es-ES');
                      const mensaje = `No se puede anular la venta porque el cierre de caja del ${fechaCierre} ya est√° cerrado.\n\nPara anular esta venta, debe reabrir primero el cierre de caja correspondiente.`;
                      reject(new Error(mensaje));
                      return;
                    }
                    
                    // Si el cierre no est√° cerrado o no existe, proceder con la anulaci√≥n
                    procederAnulacion();
                  }
                );
              } else {
                // Si no tiene cierre asignado, proceder directamente
                procederAnulacion();
              }
              
              // Funci√≥n para proceder con la anulaci√≥n
              function procederAnulacion() {
                // PASO 4: Proceder con la anulaci√≥n
                self.db.run(
                  'UPDATE ventas SET anulada = 1 WHERE id = ?',
                  [ventaId],
                  (err) => {
                    if (err) {
                      reject(new Error(`Error al anular la venta: ${err.message}`));
                      return;
                    }
                    
                    self.db.run(
                      'UPDATE tickets SET anulado = 1 WHERE venta_id = ?',
                      [ventaId],
                      (err2) => {
                        if (err2) {
                          reject(new Error(`Error al anular los tickets: ${err2.message}`));
                        } else {
                          resolve({ 
                            ventaId, 
                            anulada: true,
                            ticketsAnulados: tickets.length 
                          });
                        }
                      }
                    );
                  }
                );
              }
            }
          );
        }
      );
    });
  }
  
  constructor() {
    this.db = new sqlite3.Database(dbPath);
    this.initialize();
  }

    // Obtener todos los usuarios
    getUsers() {
      return new Promise((resolve, reject) => {
        this.db.all(
          'SELECT id, nombre, usuario, rol, activo, fecha_creacion FROM usuarios ORDER BY id DESC',
          [],
          (err, rows) => {
            if (err) reject(err);
            else resolve(rows);
          }
        );
      });
    }

    // Crear un nuevo usuario
    createUser(data) {
      return new Promise((resolve, reject) => {
        const bcrypt = require('bcryptjs');
        const { nombre, usuario, password, rol } = data;
        
        // Validaciones detalladas
        if (!nombre || nombre.trim() === '') {
          reject(new Error('El nombre del usuario no puede estar vac√≠o'));
          return;
        }
        
        if (nombre.trim().length < 3) {
          reject(new Error('El nombre del usuario debe tener al menos 3 caracteres'));
          return;
        }
        
        if (!usuario || usuario.trim() === '') {
          reject(new Error('El nombre de usuario no puede estar vac√≠o'));
          return;
        }
        
        if (usuario.trim().length < 3) {
          reject(new Error('El nombre de usuario debe tener al menos 3 caracteres'));
          return;
        }
        
        // Validar que el usuario no tenga espacios
        if (usuario.includes(' ')) {
          reject(new Error('El nombre de usuario no puede contener espacios'));
          return;
        }
        
        if (!password || password.length < 4) {
          reject(new Error('La contrase√±a debe tener al menos 4 caracteres'));
          return;
        }
        
        if (!rol || (rol !== 'vendedor' && rol !== 'admin')) {
          reject(new Error('El rol debe ser "vendedor" o "admin"'));
          return;
        }
        
        const hashedPassword = bcrypt.hashSync(password, 10);
        
        this.db.run(
          'INSERT INTO usuarios (nombre, usuario, password, rol) VALUES (?, ?, ?, ?)',
          [nombre.trim(), usuario.trim(), hashedPassword, rol],
          function(err) {
            if (err) {
              if (err.message && err.message.includes('UNIQUE')) {
                reject(new Error(`Ya existe un usuario con el nombre de usuario "${usuario.trim()}". Por favor use otro nombre de usuario.`));
              } else {
                reject(new Error(`Error al crear el usuario: ${err.message}`));
              }
            } else {
              resolve({ id: this.lastID, nombre: nombre.trim(), usuario: usuario.trim(), rol, activo: 1 });
            }
          }
        );
      });
    }

    // Actualizar datos de usuario (nombre, usuario, rol)
    updateUser(data) {
      return new Promise((resolve, reject) => {
        const { id, nombre, usuario, rol } = data;
        
        // Validaciones detalladas
        if (!nombre || nombre.trim() === '') {
          reject(new Error('El nombre del usuario no puede estar vac√≠o'));
          return;
        }
        
        if (nombre.trim().length < 3) {
          reject(new Error('El nombre del usuario debe tener al menos 3 caracteres'));
          return;
        }
        
        if (!usuario || usuario.trim() === '') {
          reject(new Error('El nombre de usuario no puede estar vac√≠o'));
          return;
        }
        
        if (usuario.trim().length < 3) {
          reject(new Error('El nombre de usuario debe tener al menos 3 caracteres'));
          return;
        }
        
        // Validar que el usuario no tenga espacios
        if (usuario.includes(' ')) {
          reject(new Error('El nombre de usuario no puede contener espacios'));
          return;
        }
        
        if (!rol || (rol !== 'vendedor' && rol !== 'admin')) {
          reject(new Error('El rol debe ser "vendedor" o "admin"'));
          return;
        }
        
        this.db.run(
          'UPDATE usuarios SET nombre = ?, usuario = ?, rol = ? WHERE id = ?',
          [nombre.trim(), usuario.trim(), rol, id],
          (err) => {
            if (err) {
              if (err.message && err.message.includes('UNIQUE')) {
                reject(new Error(`Ya existe otro usuario con el nombre de usuario "${usuario.trim()}". Por favor use otro nombre de usuario.`));
              } else {
                reject(new Error(`Error al actualizar el usuario: ${err.message}`));
              }
            } else {
              resolve({ id, nombre: nombre.trim(), usuario: usuario.trim(), rol });
            }
          }
        );
      });
    }

    // Cambiar contrase√±a de usuario
    changeUserPassword(id, newPassword) {
      return new Promise((resolve, reject) => {
        const bcrypt = require('bcryptjs');
        const hashedPassword = bcrypt.hashSync(newPassword, 10);
        this.db.run(
          'UPDATE usuarios SET password = ? WHERE id = ?',
          [hashedPassword, id],
          (err) => {
            if (err) reject(err);
            else resolve({ id });
          }
        );
      });
    }

    // Activar/desactivar usuario
    toggleUserStatus(id, active) {
      return new Promise((resolve, reject) => {
        this.db.run(
          'UPDATE usuarios SET activo = ? WHERE id = ?',
          [active ? 1 : 0, id],
          (err) => {
            if (err) reject(err);
            else resolve({ id, activo: active });
          }
        );
      });
    }

    // Eliminar usuario (solo si no tiene ventas asociadas)
    deleteUser(id) {
      return new Promise((resolve, reject) => {
        const self = this;
        
        // PASO 1: Verificar si el usuario existe y obtener sus datos
        this.db.get('SELECT * FROM usuarios WHERE id = ?', [id], (err, usuario) => {
          if (err) {
            reject(new Error(`Error al buscar el usuario: ${err.message}`));
            return;
          }
          
          if (!usuario) {
            reject(new Error('El usuario que intenta eliminar no existe'));
            return;
          }
          
          // PASO 2: Verificar si es el √∫ltimo administrador activo
          if (usuario.rol === 'admin') {
            this.db.get(
              'SELECT COUNT(*) as count FROM usuarios WHERE rol = "admin" AND activo = 1',
              [],
              (err, row) => {
                if (err) {
                  reject(new Error(`Error al verificar administradores: ${err.message}`));
                  return;
                }
                
                if (row.count <= 1) {
                  reject(new Error(`No se puede eliminar al usuario "${usuario.nombre}" porque es el √∫ltimo administrador activo del sistema.\n\nDebe crear otro administrador antes de eliminar este usuario.`));
                  return;
                }
                
                // Continuar con la verificaci√≥n de ventas
                verificarVentas();
              }
            );
          } else {
            // Si no es admin, continuar directamente
            verificarVentas();
          }
          
          function verificarVentas() {
            // PASO 3: Verificar si el usuario tiene ventas registradas
            self.db.get(
              'SELECT COUNT(*) as count FROM ventas WHERE usuario_id = ?',
              [id],
              (err, row) => {
                if (err) {
                  reject(new Error(`Error al verificar ventas del usuario: ${err.message}`));
                  return;
                }
                
                if (row.count > 0) {
                  // Si tiene ventas, solo desactivar (no se puede eliminar por integridad de datos)
                  const mensaje = `No se puede eliminar al usuario "${usuario.nombre}" porque tiene ${row.count} venta(s) registrada(s).\n\nEl usuario ha sido desactivado en su lugar para preservar el historial de ventas.`;
                  
                  self.db.run(
                    'UPDATE usuarios SET activo = 0 WHERE id = ?',
                    [id],
                    (err) => {
                      if (err) {
                        reject(new Error(`Error al desactivar el usuario: ${err.message}`));
                      } else {
                        resolve({ 
                          id, 
                          eliminado: false, 
                          desactivado: true,
                          mensaje: mensaje
                        });
                      }
                    }
                  );
                } else {
                  // Si no tiene ventas, eliminar permanentemente
                  self.db.run(
                    'DELETE FROM usuarios WHERE id = ?',
                    [id],
                    (err) => {
                      if (err) {
                        reject(new Error(`Error al eliminar el usuario: ${err.message}`));
                      } else {
                        resolve({ id, eliminado: true });
                      }
                    }
                  );
                }
              }
            );
          }
        });
      });
    }

  initialize() {
    this.db.serialize(() => {
      // Tabla de usuarios
      this.db.run(`
        CREATE TABLE IF NOT EXISTS usuarios (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          nombre VARCHAR(100) NOT NULL,
          usuario VARCHAR(50) UNIQUE NOT NULL,
          password VARCHAR(255) NOT NULL,
          rol VARCHAR(20) NOT NULL CHECK(rol IN ('vendedor', 'admin')),
          activo BOOLEAN DEFAULT 1,
          fecha_creacion TIMESTAMP DEFAULT (datetime('now', 'localtime'))
        )
      `);

      // Tabla de puertas/ubicaciones
      this.db.run(`
        CREATE TABLE IF NOT EXISTS puertas (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          nombre VARCHAR(100) NOT NULL UNIQUE,
          codigo VARCHAR(20) NOT NULL UNIQUE,
          descripcion TEXT,
          lector_ip VARCHAR(15),
          lector_port INTEGER DEFAULT 5000,
          relay_number INTEGER CHECK(relay_number BETWEEN 1 AND 4),
          tiempo_apertura_segundos INTEGER DEFAULT 5 CHECK(tiempo_apertura_segundos BETWEEN 1 AND 60),
          activo BOOLEAN DEFAULT 1,
          fecha_creacion TIMESTAMP DEFAULT (datetime('now', 'localtime'))
        )
      `);

      // Tabla de tipos de tickets
      this.db.run(`
        CREATE TABLE IF NOT EXISTS tipos_ticket (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          nombre VARCHAR(50) NOT NULL UNIQUE,
          precio DECIMAL(10,2) NOT NULL CHECK(precio > 0),
          puerta_id INTEGER,
          activo BOOLEAN DEFAULT 1,
          fecha_creacion TIMESTAMP DEFAULT (datetime('now', 'localtime')),
          FOREIGN KEY (puerta_id) REFERENCES puertas(id)
        )
      `);

      // Tabla de ventas
      this.db.run(`
        CREATE TABLE IF NOT EXISTS ventas (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          usuario_id INTEGER NOT NULL,
          total DECIMAL(10,2) NOT NULL,
          fecha_venta TIMESTAMP DEFAULT (datetime('now', 'localtime')),
          anulada BOOLEAN DEFAULT 0,
          FOREIGN KEY (usuario_id) REFERENCES usuarios(id)
        )
      `);

      // Tabla de tickets vendidos
      this.db.run(`
        CREATE TABLE IF NOT EXISTS tickets (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          venta_id INTEGER NOT NULL,
          tipo_ticket_id INTEGER NOT NULL,
          codigo_qr VARCHAR(150) UNIQUE NOT NULL,
          puerta_codigo VARCHAR(20),
          precio DECIMAL(10,2) NOT NULL,
          fecha_creacion TIMESTAMP DEFAULT (datetime('now', 'localtime')),
          anulado BOOLEAN DEFAULT 0,
          usado BOOLEAN DEFAULT 0,
          fecha_uso TIMESTAMP,
          FOREIGN KEY (venta_id) REFERENCES ventas(id),
          FOREIGN KEY (tipo_ticket_id) REFERENCES tipos_ticket(id)
        )
      `);

      // Tabla de cierres de caja
      this.db.run(`
        CREATE TABLE IF NOT EXISTS cierres_caja (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          usuario_id INTEGER NOT NULL,
          fecha_inicio TIMESTAMP NOT NULL,
          fecha_cierre TIMESTAMP DEFAULT (datetime('now', 'localtime')),
          total_ventas DECIMAL(10,2) NOT NULL,
          cantidad_tickets INTEGER NOT NULL,
          detalle_tipos TEXT,
          FOREIGN KEY (usuario_id) REFERENCES usuarios(id)
        )
      `);

      // Tabla de configuraci√≥n del relay X-410
      this.db.run(`
        CREATE TABLE IF NOT EXISTS config_relay (
          id INTEGER PRIMARY KEY CHECK (id = 1),
          ip VARCHAR(15) NOT NULL DEFAULT '192.168.3.200',
          port INTEGER NOT NULL DEFAULT 80,
          timeout INTEGER NOT NULL DEFAULT 3000,
          reintentos INTEGER NOT NULL DEFAULT 3,
          modo_rele1 VARCHAR(2) DEFAULT 'NA' CHECK(modo_rele1 IN ('NA', 'NC')),
          modo_rele2 VARCHAR(2) DEFAULT 'NA' CHECK(modo_rele2 IN ('NA', 'NC')),
          modo_rele3 VARCHAR(2) DEFAULT 'NA' CHECK(modo_rele3 IN ('NA', 'NC')),
          modo_rele4 VARCHAR(2) DEFAULT 'NA' CHECK(modo_rele4 IN ('NA', 'NC')),
          fecha_actualizacion TIMESTAMP DEFAULT (datetime('now', 'localtime'))
        )
      `);

      // Tabla de configuraci√≥n de botones f√≠sicos para impresi√≥n autom√°tica
      this.db.run(`
        CREATE TABLE IF NOT EXISTS botones_tickets (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          input_numero INTEGER NOT NULL CHECK(input_numero BETWEEN 1 AND 4),
          tipo_ticket_id INTEGER NOT NULL,
          cantidad INTEGER NOT NULL DEFAULT 1 CHECK(cantidad > 0),
          descripcion TEXT,
          activo BOOLEAN DEFAULT 1,
          fecha_creacion TIMESTAMP DEFAULT (datetime('now', 'localtime')),
          fecha_actualizacion TIMESTAMP DEFAULT (datetime('now', 'localtime')),
          FOREIGN KEY (tipo_ticket_id) REFERENCES tipos_ticket(id),
          UNIQUE(input_numero)
        )
      `, (err) => {
        if (err) {
          console.error('Error creating botones_tickets table:', err);
        }
      });

      // Tabla de logs de configuraci√≥n (historial de cambios del admin)
      this.db.run(`
        CREATE TABLE IF NOT EXISTS config_logs (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          accion VARCHAR(20) NOT NULL CHECK(accion IN ('crear', 'modificar', 'eliminar')),
          tabla_afectada VARCHAR(50) NOT NULL CHECK(tabla_afectada IN ('puertas', 'config_relay', 'tipos_ticket', 'botones_tickets')),
          registro_id INTEGER,
          descripcion TEXT,
          datos_anteriores TEXT,
          datos_nuevos TEXT,
          fecha_hora TIMESTAMP DEFAULT (datetime('now', 'localtime')),
          ip_address VARCHAR(45)
        )
      `, (err) => {
        if (err) {
          console.error('Error creating config_logs table:', err);
        }
      });

  // Insertar usuario admin por defecto
  this.insertDefaultUsers();
      
      // Ejecutar migraciones
      this.runMigrations();
    });
  }

  runMigrations() {
    // Migraci√≥n: Agregar cierre_caja_id a ventas
    this.db.all("PRAGMA table_info(ventas)", [], (err, columns) => {
      if (err) {
        console.error('Error checking ventas table schema:', err);
        return;
      }
      
      const columnNames = columns.map(col => col.name);
      
      // Agregar cierre_caja_id si no existe
      if (!columnNames.includes('cierre_caja_id')) {
        this.db.run("ALTER TABLE ventas ADD COLUMN cierre_caja_id INTEGER REFERENCES cierres_caja(id)", (err) => {
          if (err) console.error('Error adding cierre_caja_id column:', err);
          else console.log('‚úÖ Columna cierre_caja_id agregada a tabla ventas');
        });
      }
    });

    // Migraci√≥n: Agregar columnas de configuraci√≥n de relay a puertas existentes
    this.db.all("PRAGMA table_info(puertas)", [], (err, columns) => {
      if (err) {
        console.error('Error checking puertas table schema:', err);
        return;
      }
      
      const columnNames = columns.map(col => col.name);
      
      // Agregar lector_ip si no existe
      if (!columnNames.includes('lector_ip')) {
        this.db.run("ALTER TABLE puertas ADD COLUMN lector_ip VARCHAR(15)", (err) => {
          if (err) console.error('Error adding lector_ip column:', err);
        });
      }
      
      // Agregar lector_port si no existe
      if (!columnNames.includes('lector_port')) {
        this.db.run("ALTER TABLE puertas ADD COLUMN lector_port INTEGER DEFAULT 5000", (err) => {
          if (err) console.error('Error adding lector_port column:', err);
        });
      }
      
      // Agregar relay_number si no existe
      if (!columnNames.includes('relay_number')) {
        this.db.run("ALTER TABLE puertas ADD COLUMN relay_number INTEGER CHECK(relay_number BETWEEN 1 AND 4)", (err) => {
          if (err) console.error('Error adding relay_number column:', err);
        });
      }
      
      // Agregar tiempo_apertura_segundos si no existe
      if (!columnNames.includes('tiempo_apertura_segundos')) {
        this.db.run("ALTER TABLE puertas ADD COLUMN tiempo_apertura_segundos INTEGER DEFAULT 5 CHECK(tiempo_apertura_segundos BETWEEN 1 AND 60)", (err) => {
          if (err) console.error('Error adding tiempo_apertura_segundos column:', err);
        });
      }
      
      // Agregar modo_rele si no existe (NA = Normalmente Abierto, NC = Normalmente Cerrado)
      if (!columnNames.includes('modo_rele')) {
        this.db.run("ALTER TABLE puertas ADD COLUMN modo_rele VARCHAR(2) DEFAULT 'NA' CHECK(modo_rele IN ('NA', 'NC'))", (err) => {
          if (err) console.error('Error adding modo_rele column:', err);
        });
      }
    });
    
    // Migraci√≥n: Agregar columnas de modo_rele a config_relay
    this.db.all("PRAGMA table_info(config_relay)", [], (err, columns) => {
      if (err) {
        console.error('Error checking config_relay table schema:', err);
        return;
      }
      
      const columnNames = columns.map(col => col.name);
      
      // Agregar modo_rele1 si no existe
      if (!columnNames.includes('modo_rele1')) {
        this.db.run("ALTER TABLE config_relay ADD COLUMN modo_rele1 VARCHAR(2) DEFAULT 'NA' CHECK(modo_rele1 IN ('NA', 'NC'))", (err) => {
          if (err) console.error('Error adding modo_rele1 column:', err);
        });
      }
      
      // Agregar modo_rele2 si no existe
      if (!columnNames.includes('modo_rele2')) {
        this.db.run("ALTER TABLE config_relay ADD COLUMN modo_rele2 VARCHAR(2) DEFAULT 'NA' CHECK(modo_rele2 IN ('NA', 'NC'))", (err) => {
          if (err) console.error('Error adding modo_rele2 column:', err);
        });
      }
      
      // Agregar modo_rele3 si no existe
      if (!columnNames.includes('modo_rele3')) {
        this.db.run("ALTER TABLE config_relay ADD COLUMN modo_rele3 VARCHAR(2) DEFAULT 'NA' CHECK(modo_rele3 IN ('NA', 'NC'))", (err) => {
          if (err) console.error('Error adding modo_rele3 column:', err);
        });
      }
      
      // Agregar modo_rele4 si no existe
      if (!columnNames.includes('modo_rele4')) {
        this.db.run("ALTER TABLE config_relay ADD COLUMN modo_rele4 VARCHAR(2) DEFAULT 'NA' CHECK(modo_rele4 IN ('NA', 'NC'))", (err) => {
          if (err) console.error('Error adding modo_rele4 column:', err);
        });
      }
    });
    
    // Migraci√≥n: Agregar columnas de impresi√≥n a tickets existentes
    this.db.all("PRAGMA table_info(tickets)", [], (err, columns) => {
      if (err) {
        console.error('Error checking tickets table schema:', err);
        return;
      }
      
      const columnNames = columns.map(col => col.name);
      
      // Agregar impreso si no existe
      if (!columnNames.includes('impreso')) {
        this.db.run("ALTER TABLE tickets ADD COLUMN impreso BOOLEAN DEFAULT 0", (err) => {
          if (err) console.error('Error adding impreso column:', err);
        });
      }
      
      // Agregar fecha_impresion si no existe
      if (!columnNames.includes('fecha_impresion')) {
        this.db.run("ALTER TABLE tickets ADD COLUMN fecha_impresion TIMESTAMP", (err) => {
          if (err) console.error('Error adding fecha_impresion column:', err);
        });
      }
    });

    // Migraci√≥n: Agregar UNIQUE constraint a cierres_caja para (usuario_id, fecha_inicio)
    // SQLite no permite modificar constraints, as√≠ que recreamos la tabla
    this.db.get("SELECT name FROM sqlite_master WHERE type='table' AND name='cierres_caja'", [], (err, table) => {
      if (err) {
        console.error('Error checking cierres_caja table:', err);
        return;
      }
      
      if (table) {
        // Verificar si existe el √≠ndice √∫nico (que NO queremos)
        this.db.get("SELECT name FROM sqlite_master WHERE type='index' AND name='unique_usuario_fecha_cierre'", [], (err, index) => {
          if (err) {
            console.error('Error checking index:', err);
            return;
          }
          
          if (index) {
            // ELIMINAR el √≠ndice √∫nico porque ahora permitimos m√∫ltiples cierres por d√≠a
            console.log('Eliminando √≠ndice UNIQUE de cierres_caja para permitir m√∫ltiples cierres por d√≠a...');
            this.db.run('DROP INDEX IF EXISTS unique_usuario_fecha_cierre', (err) => {
              if (err) {
                console.error('Error al eliminar √≠ndice √∫nico:', err);
              } else {
                console.log('‚úÖ √çndice UNIQUE eliminado - Ahora se permiten m√∫ltiples cierres por d√≠a');
              }
            });
          }
        });
      }
    });

    // Migraci√≥n: Agregar campo 'cerrado' a cierres_caja
    this.db.all("PRAGMA table_info(cierres_caja)", [], (err, columns) => {
      if (err) {
        console.error('Error checking cierres_caja table schema:', err);
        return;
      }
      
      const columnNames = columns.map(col => col.name);
      
      // Agregar cerrado si no existe (0 = abierto, 1 = cerrado)
      if (!columnNames.includes('cerrado')) {
        this.db.run("ALTER TABLE cierres_caja ADD COLUMN cerrado BOOLEAN DEFAULT 1", (err) => {
          if (err) console.error('Error adding cerrado column:', err);
          else console.log('‚úÖ Columna cerrado agregada a tabla cierres_caja');
        });
      }
    });

    // Migraci√≥n: Sistema multi-puerta - Crear tabla tipos_ticket_puertas
    this.db.get("SELECT name FROM sqlite_master WHERE type='table' AND name='tipos_ticket_puertas'", [], (err, table) => {
      if (err) {
        console.error('Error checking tipos_ticket_puertas table:', err);
        return;
      }
      
      if (!table) {
        console.log('üöÄ Iniciando migraci√≥n a sistema multi-puerta...');
        
        // Paso 1: Crear la nueva tabla de relaci√≥n
        this.db.run(`
          CREATE TABLE tipos_ticket_puertas (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            tipo_ticket_id INTEGER NOT NULL,
            puerta_id INTEGER NOT NULL,
            fecha_creacion TIMESTAMP DEFAULT (datetime('now', 'localtime')),
            FOREIGN KEY (tipo_ticket_id) REFERENCES tipos_ticket(id) ON DELETE CASCADE,
            FOREIGN KEY (puerta_id) REFERENCES puertas(id) ON DELETE CASCADE,
            UNIQUE(tipo_ticket_id, puerta_id)
          )
        `, (err) => {
          if (err) {
            console.error('‚ùå Error creando tabla tipos_ticket_puertas:', err);
            return;
          }
          console.log('‚úÖ Tabla tipos_ticket_puertas creada');
          
          // Paso 2: Migrar datos existentes de puerta_id
          this.db.all("SELECT id, puerta_id FROM tipos_ticket WHERE puerta_id IS NOT NULL", [], (err, rows) => {
            if (err) {
              console.error('‚ùå Error leyendo tipos_ticket:', err);
              return;
            }
            
            if (rows.length === 0) {
              console.log('‚ÑπÔ∏è No hay datos de puerta_id para migrar');
              this.completarMigracionMultiPuerta();
              return;
            }
            
            console.log(`üîÑ Migrando ${rows.length} relaciones tipo_ticket ‚Üí puerta...`);
            
            // Insertar cada relaci√≥n en la nueva tabla
            let completados = 0;
            rows.forEach((row) => {
              this.db.run(
                'INSERT INTO tipos_ticket_puertas (tipo_ticket_id, puerta_id) VALUES (?, ?)',
                [row.id, row.puerta_id],
                (err) => {
                  if (err) {
                    console.error(`‚ùå Error migrando tipo_ticket ${row.id}:`, err);
                  } else {
                    completados++;
                  }
                  
                  // Cuando terminamos todas las inserciones
                  if (completados === rows.length) {
                    console.log(`‚úÖ ${completados}/${rows.length} relaciones migradas a tipos_ticket_puertas`);
                    this.completarMigracionMultiPuerta();
                  }
                }
              );
            });
          });
        });
      } else {
        // Tabla ya existe, solo verificar si necesita completar la migraci√≥n (eliminar puerta_id)
        this.completarMigracionMultiPuerta();
      }
    });

    // Migraci√≥n: Verificar estructura de config_logs
    this.db.all("PRAGMA table_info(config_logs)", [], (err, columns) => {
      if (err) {
        console.error('Error checking config_logs table schema:', err);
        return;
      }
      
      if (columns.length === 0) {
        // La tabla no existe, se crear√° autom√°ticamente arriba
        return;
      }

      const columnNames = columns.map(col => col.name);
      
      // Verificar si tiene la columna fecha_hora
      if (!columnNames.includes('fecha_hora')) {
        console.log('Migrando tabla config_logs: recreando con estructura correcta...');
        
        this.db.serialize(() => {
          // Respaldar datos si existen
          this.db.run('ALTER TABLE config_logs RENAME TO config_logs_old');
          
          // Crear nueva tabla con estructura correcta
          this.db.run(`
            CREATE TABLE config_logs (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              accion VARCHAR(20) NOT NULL CHECK(accion IN ('crear', 'modificar', 'eliminar')),
              tabla_afectada VARCHAR(50) NOT NULL CHECK(tabla_afectada IN ('puertas', 'config_relay', 'tipos_ticket', 'botones_tickets')),
              registro_id INTEGER,
              descripcion TEXT,
              datos_anteriores TEXT,
              datos_nuevos TEXT,
              fecha_hora TIMESTAMP DEFAULT (datetime('now', 'localtime')),
              ip_address VARCHAR(45)
            )
          `);
          
          // Copiar datos si la tabla antigua ten√≠a una columna de fecha
          this.db.run(`
            INSERT INTO config_logs (id, accion, tabla_afectada, registro_id, descripcion, datos_anteriores, datos_nuevos, fecha_hora, ip_address)
            SELECT id, accion, tabla_afectada, registro_id, descripcion, datos_anteriores, datos_nuevos, 
                   COALESCE(fecha, timestamp, datetime('now', 'localtime')) as fecha_hora, ip_address
            FROM config_logs_old
          `, (err) => {
            if (err) {
              console.log('No se pudieron migrar datos de config_logs (tabla nueva)');
              // Eliminar tabla antigua de todos modos
              this.db.run('DROP TABLE IF EXISTS config_logs_old');
            } else {
              console.log('Datos migrados exitosamente a config_logs');
              this.db.run('DROP TABLE config_logs_old');
            }
          });
        });
      }
    });
  }

  insertDefaultUsers() {
    const bcrypt = require('bcryptjs');
    const hashedAdminPassword = bcrypt.hashSync('admin123', 10);
    const hashedVendedorPassword = bcrypt.hashSync('vendedor123', 10);
    
    // Insertar administrador
    this.db.run(`
      INSERT OR IGNORE INTO usuarios (nombre, usuario, password, rol)
      VALUES ('Administrador', 'admin', ?, 'admin')
    `, [hashedAdminPassword]);
    
    // Insertar vendedor
    // Nota: ya no insertamos usuarios de prueba autom√°ticamente.
  }

  insertDefaultPuertas() {
    // No insertar puertas por defecto en entornos de producci√≥n.
    return;
  }

  insertDefaultRelayConfig() {
    // No insertar configuraci√≥n de relay por defecto autom√°ticamente.
    return;
  }


  getUserByUsername(usuario) {
    return new Promise((resolve, reject) => {
      this.db.get(
        'SELECT * FROM usuarios WHERE usuario = ? AND activo = 1',
        [usuario],
        (err, row) => {
          if (err) reject(err);
          else resolve(row);
        }
      );
    });
  }

  // Obtener todos los tipos de tickets
  getTicketTypes() {
    return new Promise((resolve, reject) => {
      this.db.all(
        `SELECT tt.*, 
                GROUP_CONCAT(p.id) as puerta_ids,
                GROUP_CONCAT(p.nombre) as puerta_nombres,
                GROUP_CONCAT(p.codigo) as puerta_codigos
         FROM tipos_ticket tt
         LEFT JOIN tipos_ticket_puertas ttp ON tt.id = ttp.tipo_ticket_id
         LEFT JOIN puertas p ON ttp.puerta_id = p.id
         GROUP BY tt.id
         ORDER BY tt.id DESC`,
        [],
        (err, rows) => {
          if (err) {
            reject(err);
          } else {
            // Transformar los resultados para incluir arrays de puertas
            const ticketTypes = rows.map(row => ({
              ...row,
              puertas: row.puerta_ids ? row.puerta_ids.split(',').map((id, index) => {
                const nombres = row.puerta_nombres ? row.puerta_nombres.split(',') : [];
                const codigos = row.puerta_codigos ? row.puerta_codigos.split(',') : [];
                return {
                  id: parseInt(id),
                  nombre: nombres[index] || '',
                  codigo: codigos[index] || ''
                };
              }) : []
            }));
            resolve(ticketTypes);
          }
        }
      );
    });
  }

  // Obtener solo los tipos de tickets activos
  getActiveTicketTypes() {
    return new Promise((resolve, reject) => {
      this.db.all(
        `SELECT tt.*, 
                GROUP_CONCAT(p.id) as puerta_ids,
                GROUP_CONCAT(p.nombre) as puerta_nombres,
                GROUP_CONCAT(p.codigo) as puerta_codigos
         FROM tipos_ticket tt
         LEFT JOIN tipos_ticket_puertas ttp ON tt.id = ttp.tipo_ticket_id
         LEFT JOIN puertas p ON ttp.puerta_id = p.id
         WHERE tt.activo = 1
         GROUP BY tt.id
         ORDER BY tt.id DESC`,
        [],
        (err, rows) => {
          if (err) {
            reject(err);
          } else {
            // Transformar los resultados para incluir arrays de puertas
            const ticketTypes = rows.map(row => ({
              ...row,
              puertas: row.puerta_ids ? row.puerta_ids.split(',').map((id, index) => {
                const nombres = row.puerta_nombres ? row.puerta_nombres.split(',') : [];
                const codigos = row.puerta_codigos ? row.puerta_codigos.split(',') : [];
                return {
                  id: parseInt(id),
                  nombre: nombres[index] || '',
                  codigo: codigos[index] || ''
                };
              }) : []
            }));
            resolve(ticketTypes);
          }
        }
      );
    });
  }

  // Registrar una nueva venta, ahora acepta qrCode generado en el frontend
  createSale(userId, ticketTypeId, totalAmount, qrCode, puertaCodigo) {
    return new Promise((resolve, reject) => {
      // Validaciones de entrada
      if (!userId || typeof userId !== 'number') {
        reject(new Error('ID de usuario inv√°lido'));
        return;
      }
      
      if (!ticketTypeId || typeof ticketTypeId !== 'number') {
        reject(new Error('ID de tipo de ticket inv√°lido'));
        return;
      }
      
      if (!totalAmount || typeof totalAmount !== 'number' || totalAmount <= 0) {
        reject(new Error('El monto total debe ser mayor a $0'));
        return;
      }
      
      if (!qrCode || typeof qrCode !== 'string' || qrCode.trim() === '') {
        reject(new Error('El c√≥digo QR no puede estar vac√≠o'));
        return;
      }
      
      // Validar formato QR (4 partes separadas por gui√≥n)
      const partesQR = qrCode.split('-');
      if (partesQR.length !== 4) {
        reject(new Error('Formato de c√≥digo QR inv√°lido (debe tener 4 partes)'));
        return;
      }
      
      let ventaId;

      const runQuery = (query, params) => {
        return new Promise((resolve, reject) => {
          this.db.run(query, params, function(err) {
            if (err) reject(err);
            else resolve(this);
          });
        });
      };

      // Ejecutar la transacci√≥n completa
      this.db.serialize(async () => {
        try {
          // Iniciar transacci√≥n
          await runQuery('BEGIN TRANSACTION', []);

          // Insertar la venta
          const ventaResult = await runQuery(
            'INSERT INTO ventas (usuario_id, total) VALUES (?, ?)',
            [userId, totalAmount]
          );
          ventaId = ventaResult.lastID;

          // Insertar el ticket con el c√≥digo QR y puerta_codigo
          await runQuery(
            'INSERT INTO tickets (venta_id, tipo_ticket_id, codigo_qr, puerta_codigo, precio) VALUES (?, ?, ?, ?, ?)',
            [ventaId, ticketTypeId, qrCode, puertaCodigo || null, totalAmount]
          );

          // Confirmar transacci√≥n
          await runQuery('COMMIT', []);

          // Retornar resultado
          resolve({
            ventaId,
            qrCode,
            ticketTypeId,
            precio: totalAmount,
            puertaCodigo,
            fecha: getLocalDateTime()
          });
        } catch (error) {
          await runQuery('ROLLBACK', [])
            .catch(rollbackError => console.error('Error en rollback:', rollbackError));
          
          // Mejorar mensaje de error
          if (error.message && error.message.includes('UNIQUE')) {
            reject(new Error('Este c√≥digo QR ya existe en el sistema. Por favor genere uno nuevo.'));
          } else if (error.message && error.message.includes('FOREIGN KEY')) {
            reject(new Error('El tipo de ticket o usuario no existe en el sistema.'));
          } else {
            reject(new Error(`Error al crear la venta: ${error.message}`));
          }
        }
      });
    });
  }
  
  /**
   * Marca uno o varios tickets como impresos
   * @param {number} ventaId - ID de la venta cuyos tickets se marcar√°n como impresos
   * @returns {Promise} Promesa que resuelve con el n√∫mero de tickets actualizados
   */
  marcarTicketComoImpreso(ventaId) {
    return new Promise((resolve, reject) => {
      this.db.run(
        `UPDATE tickets 
         SET impreso = 1, 
             fecha_impresion = datetime('now', 'localtime')
         WHERE venta_id = ? AND impreso = 0`,
        [ventaId],
        function(err) {
          if (err) {
            console.error('Error al marcar ticket como impreso:', err);
            reject(err);
          } else {
            resolve({ 
              ventaId, 
              ticketsActualizados: this.changes 
            });
          }
        }
      );
    });
  }
  
  // Generar un c√≥digo QR √∫nico
  generateUniqueQRCode() {
    const timestamp = Date.now();
    const random = Math.floor(Math.random() * 1000000);
    return `TICKET-${timestamp}-${random}`;
  }

  // Obtener las ventas del d√≠a para un usuario
  getDailySales(userId) {
    return new Promise((resolve, reject) => {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      this.db.all(
        `SELECT v.*, t.codigo_qr, t.precio as ticket_precio, tt.nombre as tipo_ticket
         FROM ventas v
         JOIN tickets t ON v.id = t.venta_id
         JOIN tipos_ticket tt ON t.tipo_ticket_id = tt.id
         WHERE v.usuario_id = ? 
         AND date(v.fecha_venta) = date(?)
         AND v.anulada = 0
         ORDER BY v.fecha_venta DESC`,
        [userId, getLocalDate(today)],
        (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        }
      );
    });
  }

  // Obtener resumen de ventas diarias de un vendedor espec√≠fico (solo ventas NO cerradas)
  getVendedorDailySummary(userId, fecha = null) {
    return new Promise((resolve, reject) => {
      // Si no se proporciona fecha, usar la fecha actual
      const fechaConsulta = fecha || getLocalDate();
      
      this.db.all(
        `SELECT 
           tt.nombre as tipo_ticket,
           COUNT(t.id) as cantidad_tickets,
           SUM(t.precio) as total_tipo,
           v.fecha_venta
         FROM tickets t
         JOIN ventas v ON t.venta_id = v.id
         JOIN tipos_ticket tt ON t.tipo_ticket_id = tt.id
         WHERE v.usuario_id = ? 
           AND date(v.fecha_venta) = date(?)
           AND v.anulada = 0
           AND v.cierre_caja_id IS NULL
           AND t.impreso = 1
         GROUP BY tt.id, tt.nombre
         ORDER BY tt.nombre`,
        [userId, fechaConsulta],
        (err, rows) => {
          if (err) {
            reject(err);
          } else {
            // Calcular totales
            const totalTickets = rows.reduce((sum, row) => sum + row.cantidad_tickets, 0);
            const totalVentas = rows.reduce((sum, row) => sum + row.total_tipo, 0);
            
            resolve({
              fecha: fechaConsulta,
              total_tickets: totalTickets,
              total_ventas: totalVentas,
              detalle_por_tipo: rows
            });
          }
        }
      );
    });
  }

  // Crear un nuevo tipo de ticket
  createTicketType(data) {
    return new Promise((resolve, reject) => {
      const { nombre, precio, puerta_ids = [] } = data;
      
      // Log para debugging
      console.log('createTicketType called with:', { nombre, precio, puerta_ids, puerta_ids_type: typeof puerta_ids, puerta_ids_isArray: Array.isArray(puerta_ids) });
      
      // Validaciones detalladas
      if (!nombre || nombre.trim() === '') {
        reject(new Error('El nombre del tipo de ticket no puede estar vac√≠o'));
        return;
      }
      
      if (nombre.trim().length < 3) {
        reject(new Error('El nombre del tipo de ticket debe tener al menos 3 caracteres'));
        return;
      }
      
      if (!precio || isNaN(precio)) {
        reject(new Error('El precio debe ser un n√∫mero v√°lido'));
        return;
      }
      
      if (precio <= 0) {
        reject(new Error('El precio debe ser mayor a $0'));
        return;
      }
      
      if (precio > 999999) {
        reject(new Error('El precio no puede ser mayor a $999,999'));
        return;
      }
      
      // Paso 1: Insertar el tipo de ticket (sin puerta_id)
      const self = this; // Guardar referencia a la instancia de Database
      
      this.db.run(
        'INSERT INTO tipos_ticket (nombre, precio) VALUES (?, ?)',
        [nombre.trim(), precio],
        function(err) {
          if (err) {
            if (err.message && err.message.includes('UNIQUE')) {
              reject(new Error(`Ya existe un tipo de ticket llamado "${nombre.trim()}". Por favor use otro nombre.`));
            } else {
              reject(new Error(`Error al crear el tipo de ticket: ${err.message}`));
            }
            return;
          }
          
          // IMPORTANTE: this.lastID solo funciona aqu√≠, en el contexto inmediato del callback
          const tipoTicketId = this.lastID;
          
          console.log('Ticket type created with ID:', tipoTicketId, 'this.lastID:', this.lastID);
          
          // Paso 2: Insertar relaciones con puertas si hay alguna
          if (!Array.isArray(puerta_ids) || puerta_ids.length === 0) {
            resolve({
              id: tipoTicketId,
              nombre: nombre.trim(),
              precio,
              puertas: [],
              activo: 1,
              fecha_creacion: getLocalDateTime()
            });
            return;
          }
          
          // Validar que todos los puerta_ids sean n√∫meros v√°lidos
          const puertasValidas = puerta_ids.filter(id => id && !isNaN(id) && id > 0);
          
          console.log('Puertas validation:', { 
            original: puerta_ids, 
            valid: puertasValidas,
            filtered_out: puerta_ids.filter(id => !(id && !isNaN(id) && id > 0))
          });
          
          if (puertasValidas.length === 0) {
            console.warn('No valid puerta_ids after filtering. Creating ticket type without doors.');
            resolve({
              id: tipoTicketId,
              nombre: nombre.trim(),
              precio,
              puertas: [],
              activo: 1,
              fecha_creacion: getLocalDateTime()
            });
            return;
          }
          
          // Insertar cada relaci√≥n tipo_ticket ‚Üí puerta
          const db = self.db; // Usar self en lugar de this
          let completados = 0; // Contador de callbacks completados
          let errorOcurrido = false;
          
          console.log('About to insert door relations. tipoTicketId:', tipoTicketId, 'puertasValidas:', puertasValidas);
          
          puertasValidas.forEach((puertaId) => {
            console.log('Inserting relation: tipo_ticket_id =', tipoTicketId, ', puerta_id =', puertaId);
            db.run(
              'INSERT INTO tipos_ticket_puertas (tipo_ticket_id, puerta_id) VALUES (?, ?)',
              [tipoTicketId, puertaId],
              (err) => {
                if (err && !errorOcurrido) {
                  errorOcurrido = true;
                  console.error('Error inserting door relation:', err);
                  // Si hay error, eliminar el tipo de ticket creado (rollback)
                  db.run('DELETE FROM tipos_ticket WHERE id = ?', [tipoTicketId], () => {
                    if (err.message && err.message.includes('FOREIGN KEY')) {
                      reject(new Error('Error: Una o m√°s puertas seleccionadas no existen. Por favor actualice la p√°gina e intente nuevamente.'));
                    } else if (err.message && err.message.includes('UNIQUE')) {
                      reject(new Error('Error: Relaci√≥n duplicada entre tipo de ticket y puerta.'));
                    } else {
                      reject(new Error(`Error al asignar las puertas al tipo de ticket: ${err.message}`));
                    }
                  });
                  return;
                }
                
                if (!errorOcurrido) {
                  completados++;
                  
                  // Cuando terminamos todas las inserciones
                  if (completados === puertasValidas.length) {
                    resolve({
                      id: tipoTicketId,
                      nombre: nombre.trim(),
                      precio,
                      puerta_ids: puertasValidas,
                      activo: 1,
                      fecha_creacion: getLocalDateTime()
                    });
                  }
                }
              }
            );
          });
        }
      );
    });
  }

  // Actualizar un tipo de ticket existente
  updateTicketType(data) {
    return new Promise((resolve, reject) => {
      const { id, nombre, precio, puerta_ids = [] } = data;
      
      // Validaciones detalladas
      if (!nombre || nombre.trim() === '') {
        reject(new Error('El nombre del tipo de ticket no puede estar vac√≠o'));
        return;
      }
      
      if (nombre.trim().length < 3) {
        reject(new Error('El nombre del tipo de ticket debe tener al menos 3 caracteres'));
        return;
      }
      
      if (!precio || isNaN(precio)) {
        reject(new Error('El precio debe ser un n√∫mero v√°lido'));
        return;
      }
      
      if (precio <= 0) {
        reject(new Error('El precio debe ser mayor a $0'));
        return;
      }
      
      if (precio > 999999) {
        reject(new Error('El precio no puede ser mayor a $999,999'));
        return;
      }
      
      const self = this;
      
      // Paso 1: Actualizar el tipo de ticket (sin puerta_id)
      this.db.run(
        'UPDATE tipos_ticket SET nombre = ?, precio = ? WHERE id = ?',
        [nombre.trim(), precio, id],
        (err) => {
          if (err) {
            if (err.message && err.message.includes('UNIQUE')) {
              reject(new Error(`Ya existe otro tipo de ticket llamado "${nombre.trim()}". Por favor use otro nombre.`));
            } else {
              reject(new Error(`Error al actualizar el tipo de ticket: ${err.message}`));
            }
            return;
          }
          
          // Paso 2: Eliminar relaciones anteriores con puertas
          self.db.run(
            'DELETE FROM tipos_ticket_puertas WHERE tipo_ticket_id = ?',
            [id],
            (err) => {
              if (err) {
                reject(new Error(`Error al actualizar puertas: ${err.message}`));
                return;
              }
              
              // Paso 3: Insertar nuevas relaciones
              if (!Array.isArray(puerta_ids) || puerta_ids.length === 0) {
                resolve({ 
                  id, 
                  nombre: nombre.trim(), 
                  precio, 
                  puertas: [] 
                });
                return;
              }
              
              let completados = 0; // Contador de callbacks completados
              let errorOcurrido = false;
              
              puerta_ids.forEach((puertaId) => {
                self.db.run(
                  'INSERT INTO tipos_ticket_puertas (tipo_ticket_id, puerta_id) VALUES (?, ?)',
                  [id, puertaId],
                  (err) => {
                    if (err && !errorOcurrido) {
                      errorOcurrido = true;
                      if (err.message && err.message.includes('FOREIGN KEY')) {
                        reject(new Error('Una o m√°s puertas seleccionadas no existen. Por favor actualice la p√°gina y vuelva a intentar.'));
                      } else {
                        reject(new Error(`Error al asignar las puertas al tipo de ticket: ${err.message}`));
                      }
                      return;
                    }
                    
                    if (!errorOcurrido) {
                      completados++;
                      
                      // Cuando terminamos todas las inserciones
                      if (completados === puerta_ids.length) {
                        resolve({ 
                          id, 
                          nombre: nombre.trim(), 
                          precio, 
                          puerta_ids 
                        });
                      }
                    }
                  }
                );
              });
            }
          );
        }
      );
    });
  }

  // Cambiar el estado activo/inactivo de un tipo de ticket
  toggleTicketTypeStatus(id, active) {
    return new Promise((resolve, reject) => {
      this.db.run(
        'UPDATE tipos_ticket SET activo = ? WHERE id = ?',
        [active ? 1 : 0, id],
        (err) => {
          if (err) reject(err);
          else resolve({ id, activo: active });
        }
      );
    });
  }

  // Eliminar un tipo de ticket
  deleteTicketType(id) {
    return new Promise((resolve, reject) => {
      const self = this;
      
      // PASO 1: Obtener informaci√≥n del tipo de ticket antes de eliminar
      this.db.get('SELECT * FROM tipos_ticket WHERE id = ?', [id], (err, tipoTicket) => {
        if (err) {
          reject(new Error('Error al consultar el tipo de ticket'));
          return;
        }
        
        if (!tipoTicket) {
          reject(new Error('El tipo de ticket no existe'));
          return;
        }
        
        // PASO 2: Verificar si hay tickets vendidos con este tipo
        self.db.get(
          'SELECT COUNT(*) as count FROM tickets WHERE tipo_ticket_id = ?',
          [id],
          (err, row) => {
            if (err) {
              reject(new Error('Error al verificar tickets vendidos'));
              return;
            }

            if (row.count > 0) {
              // Si hay tickets vendidos, NO se puede eliminar
              const mensaje = row.count === 1
                ? `No se puede eliminar "${tipoTicket.nombre}" porque existe 1 ticket vendido con este tipo.\n\nPuede desactivarlo en su lugar para que no aparezca en ventas nuevas.`
                : `No se puede eliminar "${tipoTicket.nombre}" porque existen ${row.count} tickets vendidos con este tipo.\n\nPuede desactivarlo en su lugar para que no aparezca en ventas nuevas.`;
              
              reject(new Error(mensaje));
              return;
            }

            // PASO 3: Si no hay tickets vendidos, eliminar relaciones y luego el tipo
            self.db.run(
              'DELETE FROM tipos_ticket_puertas WHERE tipo_ticket_id = ?',
              [id],
              (err) => {
                if (err) {
                  reject(new Error('Error al eliminar las relaciones de puertas'));
                  return;
                }
                
                // Ahora s√≠ eliminar el tipo de ticket
                self.db.run(
                  'DELETE FROM tipos_ticket WHERE id = ?',
                  [id],
                  (err) => {
                    if (err) {
                      reject(new Error(`Error al eliminar el tipo de ticket: ${err.message}`));
                    } else {
                      resolve({ 
                        success: true, 
                        message: `Tipo de ticket "${tipoTicket.nombre}" eliminado correctamente` 
                      });
                    }
                  }
                );
              }
            );
          }
        );
      });
    });
  }

  /**
   * Obtener las puertas asociadas a un tipo de ticket espec√≠fico
   * @param {number} tipoTicketId - ID del tipo de ticket
   * @returns {Promise<Array>} Array de puertas asociadas
   */
  getTicketTypeDoors(tipoTicketId) {
    return new Promise((resolve, reject) => {
      this.db.all(
        `SELECT p.* 
         FROM puertas p
         INNER JOIN tipos_ticket_puertas ttp ON p.id = ttp.puerta_id
         WHERE ttp.tipo_ticket_id = ?
         ORDER BY p.nombre`,
        [tipoTicketId],
        (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        }
      );
    });
  }

  // ============================================
  // M√âTODOS PARA PUERTAS/UBICACIONES
  // ============================================

  // Obtener todas las puertas
  getPuertas() {
    return new Promise((resolve, reject) => {
      this.db.all(
        'SELECT * FROM puertas ORDER BY id DESC',
        [],
        (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        }
      );
    });
  }

  // Obtener solo puertas activas
  getActivePuertas() {
    return new Promise((resolve, reject) => {
      this.db.all(
        'SELECT * FROM puertas WHERE activo = 1 ORDER BY nombre ASC',
        [],
        (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        }
      );
    });
  }

  // Crear una nueva puerta
  createPuerta(data) {
    return new Promise((resolve, reject) => {
      const self = this;
      const { nombre, codigo, descripcion, lector_ip, lector_port, relay_number, tiempo_apertura_segundos } = data;
      
      // Validaciones detalladas
      if (!nombre || nombre.trim() === '') {
        reject(new Error('El nombre de la puerta no puede estar vac√≠o'));
        return;
      }
      
      if (nombre.trim().length < 3) {
        reject(new Error('El nombre de la puerta debe tener al menos 3 caracteres'));
        return;
      }
      
      if (!codigo || codigo.trim() === '') {
        reject(new Error('El c√≥digo de la puerta no puede estar vac√≠o'));
        return;
      }
      
      // Validar que el c√≥digo solo contenga letras y n√∫meros
      if (!/^[A-Za-z0-9]+$/.test(codigo.trim())) {
        reject(new Error('El c√≥digo solo puede contener letras y n√∫meros (sin espacios ni caracteres especiales)'));
        return;
      }
      
      // Validar IP del lector si se proporciona
      if (lector_ip && lector_ip.trim() !== '' && !/^(\d{1,3}\.){3}\d{1,3}$/.test(lector_ip.trim())) {
        reject(new Error('La direcci√≥n IP del lector no es v√°lida. Use el formato: 192.168.1.100'));
        return;
      }
      
      // Validar puerto del lector
      if (lector_port && (lector_port < 1 || lector_port > 65535)) {
        reject(new Error('El puerto del lector debe estar entre 1 y 65535'));
        return;
      }
      
      // Validar n√∫mero de relay si se proporciona
      if (relay_number && (relay_number < 1 || relay_number > 4)) {
        reject(new Error('El n√∫mero de relay debe ser 1, 2, 3 o 4'));
        return;
      }
      
      // Validar tiempo de apertura si se proporciona
      if (tiempo_apertura_segundos && (tiempo_apertura_segundos < 1 || tiempo_apertura_segundos > 60)) {
        reject(new Error('El tiempo de apertura debe estar entre 1 y 60 segundos'));
        return;
      }
      
      this.db.run(
        `INSERT INTO puertas (nombre, codigo, descripcion, lector_ip, lector_port, relay_number, tiempo_apertura_segundos) 
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          nombre.trim(), 
          codigo.trim().toUpperCase(), 
          descripcion || null,
          lector_ip ? lector_ip.trim() : null,
          lector_port || 5000,
          relay_number || null,
          tiempo_apertura_segundos || 5
        ],
        function(err) {
          if (err) {
            if (err.message && err.message.includes('UNIQUE')) {
              if (err.message.includes('codigo')) {
                reject(new Error(`Ya existe una puerta con el c√≥digo "${codigo.trim().toUpperCase()}". Por favor use otro c√≥digo.`));
              } else {
                reject(new Error(`Ya existe una puerta con el nombre "${nombre.trim()}". Por favor use otro nombre.`));
              }
            } else {
              reject(new Error(`Error al crear la puerta: ${err.message}`));
            }
          } else {
            const datosNuevos = {
              id: this.lastID,
              nombre: nombre.trim(),
              codigo: codigo.trim().toUpperCase(),
              descripcion,
              lector_ip: lector_ip ? lector_ip.trim() : null,
              lector_port: lector_port || 5000,
              relay_number: relay_number || null,
              tiempo_apertura_segundos: tiempo_apertura_segundos || 5,
              activo: 1,
              fecha_creacion: getLocalDateTime()
            };

            // Registrar log de creaci√≥n
            self.registrarLogConfig({
              accion: 'crear',
              tabla_afectada: 'puertas',
              registro_id: datosNuevos.id,
              descripcion: `Creaci√≥n de puerta: ${datosNuevos.nombre}`,
              datos_anteriores: null,
              datos_nuevos: datosNuevos
            }).catch(err => {
              console.error('Error al registrar log de creaci√≥n de puerta:', err);
            });

            resolve(datosNuevos);
          }
        }
      );
    });
  }

  // Actualizar una puerta
  updatePuerta(data) {
    return new Promise((resolve, reject) => {
      const self = this;
      const { id, nombre, codigo, descripcion, lector_ip, lector_port, relay_number, tiempo_apertura_segundos } = data;
      
      // Validaciones detalladas
      if (!nombre || nombre.trim() === '') {
        reject(new Error('El nombre de la puerta no puede estar vac√≠o'));
        return;
      }
      
      if (nombre.trim().length < 3) {
        reject(new Error('El nombre de la puerta debe tener al menos 3 caracteres'));
        return;
      }
      
      if (!codigo || codigo.trim() === '') {
        reject(new Error('El c√≥digo de la puerta no puede estar vac√≠o'));
        return;
      }
      
      // Validar que el c√≥digo solo contenga letras y n√∫meros
      if (!/^[A-Za-z0-9]+$/.test(codigo.trim())) {
        reject(new Error('El c√≥digo solo puede contener letras y n√∫meros (sin espacios ni caracteres especiales)'));
        return;
      }
      
      // Validar IP del lector si se proporciona
      if (lector_ip && lector_ip.trim() !== '' && !/^(\d{1,3}\.){3}\d{1,3}$/.test(lector_ip.trim())) {
        reject(new Error('La direcci√≥n IP del lector no es v√°lida. Use el formato: 192.168.1.100'));
        return;
      }
      
      // Validar puerto del lector
      if (lector_port && (lector_port < 1 || lector_port > 65535)) {
        reject(new Error('El puerto del lector debe estar entre 1 y 65535'));
        return;
      }
      
      // Validar n√∫mero de relay si se proporciona
      if (relay_number && (relay_number < 1 || relay_number > 4)) {
        reject(new Error('El n√∫mero de relay debe ser 1, 2, 3 o 4'));
        return;
      }
      
      // Validar tiempo de apertura si se proporciona
      if (tiempo_apertura_segundos && (tiempo_apertura_segundos < 1 || tiempo_apertura_segundos > 60)) {
        reject(new Error('El tiempo de apertura debe estar entre 1 y 60 segundos'));
        return;
      }
      
      // PASO 1: Obtener datos anteriores para el log
      this.db.get('SELECT * FROM puertas WHERE id = ?', [id], (err, datosAnteriores) => {
        if (err) {
          reject(new Error(`Error al buscar la puerta: ${err.message}`));
          return;
        }
        
        if (!datosAnteriores) {
          reject(new Error('La puerta que intenta actualizar no existe'));
          return;
        }

        // PASO 2: Actualizar la puerta
        this.db.run(
          `UPDATE puertas SET 
            nombre = ?, 
            codigo = ?, 
            descripcion = ?,
            lector_ip = ?,
            lector_port = ?,
            relay_number = ?,
            tiempo_apertura_segundos = ?
           WHERE id = ?`,
          [
            nombre.trim(), 
            codigo.trim().toUpperCase(), 
            descripcion || null,
            lector_ip ? lector_ip.trim() : null,
            lector_port || 5000,
            relay_number || null,
            tiempo_apertura_segundos || 5,
            id
          ],
          (err) => {
            if (err) {
              if (err.message && err.message.includes('UNIQUE')) {
                if (err.message.includes('codigo')) {
                  reject(new Error(`Ya existe otra puerta con el c√≥digo "${codigo.trim().toUpperCase()}". Por favor use otro c√≥digo.`));
                } else {
                  reject(new Error(`Ya existe otra puerta con el nombre "${nombre.trim()}". Por favor use otro nombre.`));
                }
              } else {
                reject(new Error(`Error al actualizar la puerta: ${err.message}`));
              }
            } else {
              const datosNuevos = { 
                id, 
                nombre: nombre.trim(), 
                codigo: codigo.trim().toUpperCase(), 
                descripcion,
                lector_ip: lector_ip ? lector_ip.trim() : null,
                lector_port: lector_port || 5000,
                relay_number: relay_number || null,
                tiempo_apertura_segundos: tiempo_apertura_segundos || 5
              };

              // PASO 3: Registrar el log
              self.registrarLogConfig({
                accion: 'modificar',
                tabla_afectada: 'puertas',
                registro_id: id,
                descripcion: `Modificaci√≥n de puerta: ${nombre}`,
                datos_anteriores: datosAnteriores,
                datos_nuevos: datosNuevos
              }).catch(err => {
                // Log de error pero no rechazar la operaci√≥n principal
                console.error('Error al registrar log de modificaci√≥n de puerta:', err);
              });

              resolve(datosNuevos);
            }
          }
        );
      });
    });
  }

  // Cambiar estado activo/inactivo de una puerta
  togglePuertaStatus(id, active) {
    return new Promise((resolve, reject) => {
      this.db.run(
        'UPDATE puertas SET activo = ? WHERE id = ?',
        [active ? 1 : 0, id],
        (err) => {
          if (err) reject(err);
          else resolve({ id, activo: active });
        }
      );
    });
  }

  // Eliminar una puerta
  deletePuerta(id) {
    return new Promise((resolve, reject) => {
      const self = this;
      
      // PASO 1: Verificar si la puerta existe y obtener sus datos
      this.db.get('SELECT * FROM puertas WHERE id = ?', [id], (err, puerta) => {
        if (err) {
          reject(new Error(`Error al buscar la puerta: ${err.message}`));
          return;
        }
        
        if (!puerta) {
          reject(new Error('La puerta que intenta eliminar no existe'));
          return;
        }

        // PASO 2: Verificar si la puerta est√° asignada a tipos de tickets
        this.db.all(
          `SELECT tt.id, tt.nombre 
           FROM tipos_ticket tt
           INNER JOIN tipos_ticket_puertas ttp ON tt.id = ttp.tipo_ticket_id
           WHERE ttp.puerta_id = ?`,
          [id],
          (err, tiposTicket) => {
            if (err) {
              reject(new Error(`Error al verificar asignaciones de la puerta: ${err.message}`));
              return;
            }

            // Si la puerta est√° asignada a tipos de ticket, no permitir eliminaci√≥n
            if (tiposTicket && tiposTicket.length > 0) {
              const nombresTickets = tiposTicket.map(t => `"${t.nombre}"`).join(', ');
              const mensaje = `No se puede eliminar la puerta "${puerta.nombre}" porque est√° asignada a ${tiposTicket.length} tipo(s) de ticket: ${nombresTickets}.\n\nPuede desactivarla en su lugar para que no est√© disponible sin perder el historial.`;
              reject(new Error(mensaje));
              return;
            }

            // PASO 3: Si no est√° asignada, eliminar las relaciones y la puerta
            this.db.run(
              'DELETE FROM tipos_ticket_puertas WHERE puerta_id = ?',
              [id],
              (err) => {
                if (err) {
                  reject(new Error(`Error al eliminar relaciones de la puerta: ${err.message}`));
                  return;
                }

                // PASO 4: Ahora eliminar la puerta
                this.db.run(
                  'DELETE FROM puertas WHERE id = ?',
                  [id],
                  (err) => {
                    if (err) {
                      reject(new Error(`Error al eliminar la puerta: ${err.message}`));
                      return;
                    }
                    
                    // Registrar log de eliminaci√≥n
                    self.registrarLogConfig({
                      accion: 'eliminar',
                      tabla_afectada: 'puertas',
                      registro_id: id,
                      descripcion: `Eliminaci√≥n de puerta: ${puerta.nombre}`,
                      datos_anteriores: puerta,
                      datos_nuevos: null
                    }).catch(err => {
                      console.error('Error al registrar log de eliminaci√≥n de puerta:', err);
                    });

                    resolve({ success: true, wasDeactivated: false });
                  }
                );
              }
            );
          }
        );
      });
    });
  }

  // ============================================
  // M√âTODOS PARA CONFIGURACI√ìN DEL RELAY X-410
  // ============================================

  // Obtener configuraci√≥n del relay X-410
  getConfigRelay() {
    return new Promise((resolve, reject) => {
      this.db.get(
        'SELECT * FROM config_relay WHERE id = 1',
        [],
        (err, row) => {
          if (err) {
            reject(err);
          } else if (row) {
            resolve(row);
          } else {
            // Si no existe, crear configuraci√≥n por defecto
            this.db.run(
              `INSERT OR IGNORE INTO config_relay (id, ip, port, timeout, reintentos) 
               VALUES (1, '192.168.3.200', 80, 3000, 3)`,
              (err) => {
                if (err) {
                  reject(err);
                } else {
                  // Retornar configuraci√≥n por defecto consultando de nuevo
                  this.db.get(
                    'SELECT * FROM config_relay WHERE id = 1',
                    [],
                    (err, row) => {
                      if (err) {
                        reject(err);
                      } else {
                        resolve(row || {
                          id: 1,
                          ip: '192.168.3.200',
                          port: 80,
                          timeout: 3000,
                          reintentos: 3,
                          fecha_actualizacion: getLocalDateTime()
                        });
                      }
                    }
                  );
                }
              }
            );
          }
        }
      );
    });
  }

  // Actualizar configuraci√≥n del relay X-410
  updateConfigRelay(data) {
    return new Promise((resolve, reject) => {
      const self = this;
      const { 
        ip, 
        port, 
        timeout, 
        reintentos,
        modo_rele1 = 'NA',
        modo_rele2 = 'NA',
        modo_rele3 = 'NA',
        modo_rele4 = 'NA'
      } = data;
      
      // Validaciones
      if (!ip || !/^(\d{1,3}\.){3}\d{1,3}$/.test(ip.trim())) {
        reject(new Error('Formato de IP inv√°lido'));
        return;
      }
      
      if (!port || port < 1 || port > 65535) {
        reject(new Error('El puerto debe estar entre 1 y 65535'));
        return;
      }
      
      if (!timeout || timeout < 100 || timeout > 30000) {
        reject(new Error('El timeout debe estar entre 100 y 30000 ms'));
        return;
      }
      
      if (!reintentos || reintentos < 1 || reintentos > 10) {
        reject(new Error('Los reintentos deben estar entre 1 y 10'));
        return;
      }
      
      // Validar modos de relay
      const validModes = ['NA', 'NC'];
      if (!validModes.includes(modo_rele1) || !validModes.includes(modo_rele2) || 
          !validModes.includes(modo_rele3) || !validModes.includes(modo_rele4)) {
        reject(new Error('Los modos de relay deben ser NA o NC'));
        return;
      }
      
      // PASO 1: Obtener configuraci√≥n anterior
      this.db.get('SELECT * FROM config_relay WHERE id = 1', [], (err, datosAnteriores) => {
        if (err) {
          reject(err);
          return;
        }

        // PASO 2: Actualizar la configuraci√≥n
        this.db.run(
          `UPDATE config_relay 
           SET ip = ?, port = ?, timeout = ?, reintentos = ?, 
               modo_rele1 = ?, modo_rele2 = ?, modo_rele3 = ?, modo_rele4 = ?,
               fecha_actualizacion = datetime('now', 'localtime')
           WHERE id = 1`,
          [ip.trim(), port, timeout, reintentos, modo_rele1, modo_rele2, modo_rele3, modo_rele4],
          (err) => {
            if (err) {
              reject(err);
            } else {
              const datosNuevos = {
                id: 1,
                ip: ip.trim(),
                port,
                timeout,
                reintentos,
                modo_rele1,
                modo_rele2,
                modo_rele3,
                modo_rele4,
                fecha_actualizacion: getLocalDateTime()
              };

              // PASO 3: Registrar log
              self.registrarLogConfig({
                accion: 'modificar',
                tabla_afectada: 'config_relay',
                registro_id: 1,
                descripcion: 'Actualizaci√≥n de configuraci√≥n del relay X-410',
                datos_anteriores: datosAnteriores,
                datos_nuevos: datosNuevos
              }).catch(err => {
                console.error('Error al registrar log de configuraci√≥n del relay:', err);
              });

              resolve(datosNuevos);
            }
          }
        );
      });
    });
  }

  // ==================== M√âTODOS CRUD PARA BOTONES_TICKETS ====================

  /**
   * Obtener configuraci√≥n de un bot√≥n espec√≠fico por n√∫mero de input
   * (Usado por servidor HTTP para triggers de botones f√≠sicos)
   * @param {number} input_numero - N√∫mero del input (1-4)
   * @returns {Promise<Object|null>} Configuraci√≥n del bot√≥n o null si no existe
   */
  obtenerBotonPorInput(input_numero) {
    return new Promise((resolve, reject) => {
      if (!input_numero || input_numero < 1 || input_numero > 4) {
        reject(new Error('El n√∫mero de input debe estar entre 1 y 4'));
        return;
      }

      this.db.get(
        `SELECT b.*, t.nombre as tipo_ticket_nombre, t.precio as tipo_ticket_precio, t.puerta_id
         FROM botones_tickets b
         LEFT JOIN tipos_ticket t ON b.tipo_ticket_id = t.id
         WHERE b.input_numero = ?`,
        [input_numero],
        (err, boton) => {
          if (err) {
            reject(err);
          } else {
            resolve(boton || null);
          }
        }
      );
    });
  }

  // ============================================================================
  // LOGS DE CONFIGURACI√ìN
  // ============================================================================

  /**
   * Registrar un cambio en la configuraci√≥n
   * @param {Object} params
   * @param {string} params.accion - 'crear', 'modificar' o 'eliminar'
   * @param {string} params.tabla_afectada - 'puertas', 'config_relay', 'tipos_ticket', 'botones_tickets'
   * @param {number} params.registro_id - ID del registro afectado
   * @param {string} params.descripcion - Descripci√≥n del cambio
   * @param {Object} params.datos_anteriores - Datos antes del cambio (JSON)
   * @param {Object} params.datos_nuevos - Datos despu√©s del cambio (JSON)
   * @param {string} params.ip_address - Direcci√≥n IP (opcional)
   * @returns {Promise<number>} ID del log creado
   */
  registrarLogConfig({ accion, tabla_afectada, registro_id, descripcion, datos_anteriores, datos_nuevos, ip_address }) {
    return new Promise((resolve, reject) => {
      const accionesValidas = ['crear', 'modificar', 'eliminar'];
      const tablasValidas = ['puertas', 'config_relay', 'tipos_ticket', 'botones_tickets'];

      if (!accionesValidas.includes(accion)) {
        reject(new Error(`Acci√≥n inv√°lida. Debe ser: ${accionesValidas.join(', ')}`));
        return;
      }

      if (!tablasValidas.includes(tabla_afectada)) {
        reject(new Error(`Tabla inv√°lida. Debe ser: ${tablasValidas.join(', ')}`));
        return;
      }

      const datosAnterioresStr = datos_anteriores ? JSON.stringify(datos_anteriores) : null;
      const datosNuevosStr = datos_nuevos ? JSON.stringify(datos_nuevos) : null;

      this.db.run(
        `INSERT INTO config_logs (accion, tabla_afectada, registro_id, descripcion, datos_anteriores, datos_nuevos, ip_address)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [accion, tabla_afectada, registro_id, descripcion, datosAnterioresStr, datosNuevosStr, ip_address],
        function(err) {
          if (err) {
            reject(err);
          } else {
            resolve(this.lastID);
          }
        }
      );
    });
  }

  /**
   * Obtener logs de configuraci√≥n con filtros y paginaci√≥n
   * @param {Object} params
   * @param {number} params.limit - L√≠mite de registros
   * @param {number} params.offset - Offset para paginaci√≥n
   * @param {string} params.tabla_afectada - Filtrar por tabla (opcional)
   * @param {string} params.accion - Filtrar por acci√≥n (opcional)
   * @param {string} params.fecha_desde - Filtrar desde fecha (opcional)
   * @param {string} params.fecha_hasta - Filtrar hasta fecha (opcional)
   * @returns {Promise<Array>} Lista de logs
   */
  obtenerLogsConfig({ limit = 100, offset = 0, tabla_afectada, accion, fecha_desde, fecha_hasta } = {}) {
    return new Promise((resolve, reject) => {
      let query = 'SELECT * FROM config_logs WHERE 1=1';
      const params = [];

      if (tabla_afectada) {
        query += ' AND tabla_afectada = ?';
        params.push(tabla_afectada);
      }

      if (accion) {
        query += ' AND accion = ?';
        params.push(accion);
      }

      if (fecha_desde) {
        query += ' AND date(fecha_hora) >= date(?)';
        params.push(fecha_desde);
      }

      if (fecha_hasta) {
        query += ' AND date(fecha_hora) <= date(?)';
        params.push(fecha_hasta);
      }

      query += ' ORDER BY fecha_hora DESC LIMIT ? OFFSET ?';
      params.push(limit, offset);

      this.db.all(query, params, (err, rows) => {
        if (err) {
          reject(err);
        } else {
          // Parsear JSON de datos
          const logs = rows.map(row => ({
            ...row,
            datos_anteriores: row.datos_anteriores ? JSON.parse(row.datos_anteriores) : null,
            datos_nuevos: row.datos_nuevos ? JSON.parse(row.datos_nuevos) : null
          }));
          resolve(logs);
        }
      });
    });
  }

  /**
   * Contar total de logs con filtros
   * @param {Object} params - Mismos filtros que obtenerLogsConfig
   * @returns {Promise<number>} Total de registros
   */
  contarLogsConfig({ tabla_afectada, accion, fecha_desde, fecha_hasta } = {}) {
    return new Promise((resolve, reject) => {
      let query = 'SELECT COUNT(*) as total FROM config_logs WHERE 1=1';
      const params = [];

      if (tabla_afectada) {
        query += ' AND tabla_afectada = ?';
        params.push(tabla_afectada);
      }

      if (accion) {
        query += ' AND accion = ?';
        params.push(accion);
      }

      if (fecha_desde) {
        query += ' AND date(fecha_hora) >= date(?)';
        params.push(fecha_desde);
      }

      if (fecha_hasta) {
        query += ' AND date(fecha_hora) <= date(?)';
        params.push(fecha_hasta);
      }

      this.db.get(query, params, (err, row) => {
        if (err) {
          reject(err);
        } else {
          resolve(row.total);
        }
      });
    });
  }

  /**
   * Obtener estad√≠sticas de logs
   * @returns {Promise<Object>} Estad√≠sticas de cambios
   */
  obtenerEstadisticasLogs() {
    return new Promise((resolve, reject) => {
      const query = `
        SELECT 
          tabla_afectada,
          accion,
          COUNT(*) as cantidad,
          MAX(fecha_hora) as ultima_modificacion
        FROM config_logs
        GROUP BY tabla_afectada, accion
        ORDER BY tabla_afectada, accion
      `;

      this.db.all(query, [], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          resolve(rows);
        }
      });
    });
  }

  /**
   * Limpiar logs antiguos (mantener solo los √∫ltimos N d√≠as)
   * @param {number} dias - N√∫mero de d√≠as a mantener (por defecto 90)
   * @returns {Promise<number>} Cantidad de registros eliminados
   */
  limpiarLogsAntiguos(dias = 90) {
    return new Promise((resolve, reject) => {
      const fechaLimite = new Date();
      fechaLimite.setDate(fechaLimite.getDate() - dias);
      const fechaLimiteStr = fechaLimite.toISOString().split('T')[0];

      this.db.run(
        'DELETE FROM config_logs WHERE date(fecha_hora) < date(?)',
        [fechaLimiteStr],
        function(err) {
          if (err) {
            reject(err);
          } else {
            resolve(this.changes);
          }
        }
      );
    });
  }

  /**
   * Obtener historial de un registro espec√≠fico
   * @param {string} tabla - Nombre de la tabla
   * @param {number} registro_id - ID del registro
   * @returns {Promise<Array>} Historial de cambios
   */
  obtenerHistorialRegistro(tabla, registro_id) {
    return new Promise((resolve, reject) => {
      this.db.all(
        `SELECT * FROM config_logs 
         WHERE tabla_afectada = ? AND registro_id = ?
         ORDER BY fecha_hora DESC`,
        [tabla, registro_id],
        (err, rows) => {
          if (err) {
            reject(err);
          } else {
            const logs = rows.map(row => ({
              ...row,
              datos_anteriores: row.datos_anteriores ? JSON.parse(row.datos_anteriores) : null,
              datos_nuevos: row.datos_nuevos ? JSON.parse(row.datos_nuevos) : null
            }));
            resolve(logs);
          }
        }
      );
    });
  }

  /**
   * Completar la migraci√≥n multi-puerta eliminando la columna puerta_id
   * SQLite no permite DROP COLUMN directamente, as√≠ que recreamos la tabla
   */
  completarMigracionMultiPuerta() {
    console.log('üîÑ Paso 3: Eliminando columna puerta_id de tipos_ticket...');
    
    // Verificar si la columna puerta_id a√∫n existe
    this.db.all("PRAGMA table_info(tipos_ticket)", [], (err, columns) => {
      if (err) {
        console.error('‚ùå Error verificando estructura de tipos_ticket:', err);
        return;
      }
      
      const columnNames = columns.map(col => col.name);
      
      if (!columnNames.includes('puerta_id')) {
        console.log('‚úÖ Columna puerta_id ya fue eliminada previamente');
        return;
      }
      
      // SQLite no soporta DROP COLUMN hasta versi√≥n 3.35+, as√≠ que recreamos la tabla
      this.db.serialize(() => {
        // Paso 1: Renombrar tabla original
        this.db.run('ALTER TABLE tipos_ticket RENAME TO tipos_ticket_old', (err) => {
          if (err) {
            console.error('‚ùå Error renombrando tipos_ticket:', err);
            return;
          }
          
          // Paso 2: Crear nueva tabla sin puerta_id
          this.db.run(`
            CREATE TABLE tipos_ticket (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              nombre VARCHAR(50) NOT NULL UNIQUE,
              precio DECIMAL(10,2) NOT NULL CHECK(precio > 0),
              activo BOOLEAN DEFAULT 1,
              fecha_creacion TIMESTAMP DEFAULT (datetime('now', 'localtime'))
            )
          `, (err) => {
            if (err) {
              console.error('‚ùå Error creando nueva tabla tipos_ticket:', err);
              return;
            }
            
            // Paso 3: Copiar datos (sin puerta_id)
            this.db.run(`
              INSERT INTO tipos_ticket (id, nombre, precio, activo, fecha_creacion)
              SELECT id, nombre, precio, activo, fecha_creacion
              FROM tipos_ticket_old
            `, (err) => {
              if (err) {
                console.error('‚ùå Error copiando datos a nueva tabla tipos_ticket:', err);
                return;
              }
              
              // Paso 4: Eliminar tabla antigua
              this.db.run('DROP TABLE tipos_ticket_old', (err) => {
                if (err) {
                  console.error('‚ùå Error eliminando tabla tipos_ticket_old:', err);
                  return;
                }
                
                console.log('‚úÖ Columna puerta_id eliminada de tipos_ticket');
                
                // Paso 5: Eliminar UNIQUE index nombre_puerta si existe
                this.db.run('DROP INDEX IF EXISTS idx_tipo_ticket_nombre_puerta', (err) => {
                  if (err) {
                    console.error('‚ö†Ô∏è No se pudo eliminar √≠ndice idx_tipo_ticket_nombre_puerta:', err);
                  } else {
                    console.log('‚úÖ √çndice idx_tipo_ticket_nombre_puerta eliminado (si exist√≠a)');
                  }
                  
                  console.log('üéâ Migraci√≥n a sistema multi-puerta completada exitosamente');
                });
              });
            });
          });
        });
      });
    });
  }

  close() {
    this.db.close();
  }
}

module.exports = Database;